import {
  require_react
} from "./chunk-2UC5YKPU.js";
import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// node_modules/nuka-carousel/es/hooks/use-slide-intersection-observer.js
var require_use_slide_intersection_observer = __commonJS({
  "node_modules/nuka-carousel/es/hooks/use-slide-intersection-observer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useSlideIntersectionObserver = void 0;
    var _react = require_react();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var useSlideIntersectionObserver = function useSlideIntersectionObserver2(elementRef, rootRef, callback) {
      var _useState = (0, _react.useState)(), _useState2 = _slicedToArray(_useState, 2), entry = _useState2[0], setEntry = _useState2[1];
      var callbackRef = (0, _react.useRef)(callback);
      (0, _react.useEffect)(function() {
        callbackRef.current = callback;
      }, [callback]);
      (0, _react.useEffect)(function() {
        var node = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
        var root = rootRef === null || rootRef === void 0 ? void 0 : rootRef.current;
        if (!window.IntersectionObserver || !node || !root)
          return;
        var observer = new IntersectionObserver(function(entries) {
          entries.forEach(function(entry2) {
            setEntry(entry2);
            callbackRef.current(entry2);
          });
        }, {
          threshold: [0.05, 0.95],
          root
        });
        observer.observe(node);
        return function() {
          return observer.disconnect();
        };
      }, [elementRef, rootRef]);
      return entry;
    };
    exports.useSlideIntersectionObserver = useSlideIntersectionObserver;
  }
});

// node_modules/nuka-carousel/es/slide.js
var require_slide = __commonJS({
  "node_modules/nuka-carousel/es/slide.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _useSlideIntersectionObserver = require_use_slide_intersection_observer();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var getSlideWidth = function getSlideWidth2(count, wrapAround) {
      return "".concat(wrapAround ? 100 / (3 * count) : 100 / count, "%");
    };
    var getSlideStyles = function getSlideStyles2(count, isCurrentSlide, isVisibleSlide, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth) {
      var width = slideWidth !== null && slideWidth !== void 0 ? slideWidth : getSlideWidth(count, wrapAround);
      var visibleSlideOpacity = isVisibleSlide ? 1 : 0;
      var animationSpeed = animation === "fade" ? 200 : 500;
      var height = "auto";
      if (adaptiveHeight) {
        if (initializedAdaptiveHeight) {
          height = "100%";
        } else if (isVisibleSlide) {
          height = "auto";
        } else {
          height = "0";
        }
      }
      return {
        width,
        height,
        padding: "0 ".concat(cellSpacing ? cellSpacing / 2 : 0, "px"),
        transition: animation ? "".concat(speed || animationSpeed, "ms ease 0s") : void 0,
        transform: animation === "zoom" ? "scale(".concat(isCurrentSlide && isVisibleSlide ? 1 : zoomScale || 0.85, ")") : void 0,
        opacity: animation === "fade" ? visibleSlideOpacity : 1
      };
    };
    var generateIndex = function generateIndex2(index, count, typeOfSlide) {
      if (typeOfSlide === "prev-cloned") {
        return index - count;
      }
      if (typeOfSlide === "next-cloned") {
        return index + count;
      }
      return index;
    };
    var Slide = function Slide2(_ref) {
      var _entry$intersectionRa;
      var count = _ref.count, children = _ref.children, index = _ref.index, isCurrentSlide = _ref.isCurrentSlide, typeOfSlide = _ref.typeOfSlide, wrapAround = _ref.wrapAround, cellSpacing = _ref.cellSpacing, slideWidth = _ref.slideWidth, animation = _ref.animation, speed = _ref.speed, zoomScale = _ref.zoomScale, onVisibleSlideHeightChange = _ref.onVisibleSlideHeightChange, adaptiveHeight = _ref.adaptiveHeight, initializedAdaptiveHeight = _ref.initializedAdaptiveHeight, updateIOEntry = _ref.updateIOEntry, id = _ref.id, carouselRef = _ref.carouselRef, carouselId = _ref.carouselId, tabbed = _ref.tabbed;
      var customIndex = wrapAround ? generateIndex(index, count, typeOfSlide) : index;
      var slideRef = (0, _react.useRef)(null);
      var entry = (0, _useSlideIntersectionObserver.useSlideIntersectionObserver)(slideRef, carouselRef, function(entry2) {
        updateIOEntry(id, (entry2 === null || entry2 === void 0 ? void 0 : entry2.intersectionRatio) >= 0.95);
      });
      var isVisible = !!(entry !== null && entry !== void 0 && entry.isIntersecting);
      var isFullyVisible = ((_entry$intersectionRa = entry === null || entry === void 0 ? void 0 : entry.intersectionRatio) !== null && _entry$intersectionRa !== void 0 ? _entry$intersectionRa : 1) >= 0.95;
      var prevIsVisibleRef = (0, _react.useRef)(false);
      (0, _react.useEffect)(function() {
        var node = slideRef.current;
        if (node) {
          var _node$getBoundingClie;
          var slideHeight = (_node$getBoundingClie = node.getBoundingClientRect()) === null || _node$getBoundingClie === void 0 ? void 0 : _node$getBoundingClie.height;
          var prevIsVisible = prevIsVisibleRef.current;
          if (isVisible && !prevIsVisible) {
            onVisibleSlideHeightChange(customIndex, slideHeight);
          } else if (!isVisible && prevIsVisible) {
            onVisibleSlideHeightChange(customIndex, null);
          }
          prevIsVisibleRef.current = isVisible;
        }
      }, [customIndex, isVisible, onVisibleSlideHeightChange]);
      var currentSlideClass = isCurrentSlide && isFullyVisible ? " slide-current" : "";
      return _react["default"].createElement("div", {
        ref: slideRef,
        inert: isFullyVisible ? void 0 : "true",
        className: "slide".concat(currentSlideClass).concat(typeOfSlide ? " ".concat(typeOfSlide) : "").concat(isFullyVisible ? " slide-visible" : ""),
        style: getSlideStyles(count, isCurrentSlide, isFullyVisible, wrapAround, cellSpacing, animation, speed, zoomScale, adaptiveHeight, initializedAdaptiveHeight, slideWidth),
        id: typeOfSlide ? void 0 : "".concat(carouselId, "-slide-").concat(index + 1),
        role: tabbed ? "tabpanel" : "group",
        "aria-roledescription": tabbed ? void 0 : "slide"
      }, children);
    };
    var _default = Slide;
    exports["default"] = _default;
  }
});

// node_modules/nuka-carousel/es/announce-slide.js
var require_announce_slide = __commonJS({
  "node_modules/nuka-carousel/es/announce-slide.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultRenderAnnounceSlideMessage = exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var styles = {
      position: "absolute",
      width: "1px",
      height: "1px",
      overflow: "hidden",
      padding: 0,
      margin: "-1px",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      border: 0
    };
    var AnnounceSlide = function AnnounceSlide2(_ref) {
      var message = _ref.message, _ref$ariaLive = _ref.ariaLive, ariaLive = _ref$ariaLive === void 0 ? "polite" : _ref$ariaLive;
      return _react["default"].createElement("div", {
        "aria-live": ariaLive,
        "aria-atomic": "true",
        style: styles,
        tabIndex: -1
      }, message);
    };
    var defaultRenderAnnounceSlideMessage = function defaultRenderAnnounceSlideMessage2(_ref2) {
      var currentSlide = _ref2.currentSlide, count = _ref2.count;
      return "Slide ".concat(currentSlide + 1, " of ").concat(count);
    };
    exports.defaultRenderAnnounceSlideMessage = defaultRenderAnnounceSlideMessage;
    var _default = AnnounceSlide;
    exports["default"] = _default;
  }
});

// node_modules/nuka-carousel/es/types.js
var require_types = __commonJS({
  "node_modules/nuka-carousel/es/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScrollMode = exports.Positions = exports.Directions = exports.Alignment = void 0;
    var Alignment;
    exports.Alignment = Alignment;
    (function(Alignment2) {
      Alignment2["Center"] = "center";
      Alignment2["Right"] = "right";
      Alignment2["Left"] = "left";
    })(Alignment || (exports.Alignment = Alignment = {}));
    var Directions;
    exports.Directions = Directions;
    (function(Directions2) {
      Directions2["Next"] = "next";
      Directions2["Prev"] = "prev";
      Directions2["Up"] = "up";
      Directions2["Down"] = "down";
    })(Directions || (exports.Directions = Directions = {}));
    var Positions;
    exports.Positions = Positions;
    (function(Positions2) {
      Positions2["TopLeft"] = "TopLeft";
      Positions2["TopCenter"] = "TopCenter";
      Positions2["TopRight"] = "TopRight";
      Positions2["CenterLeft"] = "CenterLeft";
      Positions2["CenterCenter"] = "CenterCenter";
      Positions2["CenterRight"] = "CenterRight";
      Positions2["BottomLeft"] = "BottomLeft";
      Positions2["BottomCenter"] = "BottomCenter";
      Positions2["BottomRight"] = "BottomRight";
    })(Positions || (exports.Positions = Positions = {}));
    var ScrollMode;
    exports.ScrollMode = ScrollMode;
    (function(ScrollMode2) {
      ScrollMode2["page"] = "page";
      ScrollMode2["remainder"] = "remainder";
    })(ScrollMode || (exports.ScrollMode = ScrollMode = {}));
  }
});

// node_modules/nuka-carousel/es/utils.js
var require_utils = __commonJS({
  "node_modules/nuka-carousel/es/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.getDefaultSlideIndex = exports.getBoundedIndex = void 0;
    var _defaultControls = require_default_controls();
    var _types = require_types();
    var getNextMoveIndex = function getNextMoveIndex2(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) {
      if (wrapAround) {
        return currentSlide + slidesToScroll;
      }
      if (currentSlide >= slideCount - 1 || cellAlign === "left" && currentSlide >= slideCount - slidesToShow) {
        return currentSlide;
      }
      if (scrollMode === _types.ScrollMode.remainder && cellAlign === "left") {
        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);
      }
      return Math.min(currentSlide + slidesToScroll, slideCount - 1);
    };
    exports.getNextMoveIndex = getNextMoveIndex;
    var getPrevMoveIndex = function getPrevMoveIndex2(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) {
      if (wrapAround) {
        return currentSlide - slidesToScroll;
      }
      if (currentSlide <= 0 || cellAlign === "right" && currentSlide <= slidesToShow - 1) {
        return currentSlide;
      }
      if (scrollMode === _types.ScrollMode.remainder && cellAlign === "right") {
        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);
      }
      return Math.max(currentSlide - slidesToScroll, 0);
    };
    exports.getPrevMoveIndex = getPrevMoveIndex;
    var getDefaultSlideIndex = function getDefaultSlideIndex2(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) {
      if (slideIndex !== void 0) {
        return slideIndex;
      }
      var dotIndexes = (0, _defaultControls.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);
      return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];
    };
    exports.getDefaultSlideIndex = getDefaultSlideIndex;
    var getBoundedIndex = function getBoundedIndex2(rawIndex, slideCount) {
      return (rawIndex % slideCount + slideCount) % slideCount;
    };
    exports.getBoundedIndex = getBoundedIndex;
  }
});

// node_modules/nuka-carousel/es/default-controls.js
var require_default_controls = __commonJS({
  "node_modules/nuka-carousel/es/default-controls.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.prevButtonDisabled = exports.nextButtonDisabled = exports.getDotIndexes = exports.PreviousButton = exports.PagingDots = exports.NextButton = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _types = require_types();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultButtonStyles = function defaultButtonStyles2(disabled) {
      return {
        border: 0,
        background: "rgba(0,0,0,0.4)",
        color: "white",
        padding: 10,
        textTransform: "uppercase",
        opacity: disabled ? 0.3 : 1,
        cursor: disabled ? "not-allowed" : "pointer"
      };
    };
    var prevButtonDisabled = function prevButtonDisabled2(_ref) {
      var cellAlign = _ref.cellAlign, currentSlide = _ref.currentSlide, slidesToShow = _ref.slidesToShow, wrapAround = _ref.wrapAround;
      if (wrapAround) {
        return false;
      }
      if (currentSlide === 0) {
        return true;
      }
      if (cellAlign === "right" && currentSlide <= slidesToShow - 1) {
        return true;
      }
      return false;
    };
    exports.prevButtonDisabled = prevButtonDisabled;
    var PreviousButton = function PreviousButton2(_ref2) {
      var previousSlide = _ref2.previousSlide, _ref2$defaultControls = _ref2.defaultControlsConfig, prevButtonClassName = _ref2$defaultControls.prevButtonClassName, _ref2$defaultControls2 = _ref2$defaultControls.prevButtonStyle, prevButtonStyle = _ref2$defaultControls2 === void 0 ? {} : _ref2$defaultControls2, prevButtonText = _ref2$defaultControls.prevButtonText, prevButtonOnClick = _ref2$defaultControls.prevButtonOnClick, carouselId = _ref2.carouselId, onUserNavigation = _ref2.onUserNavigation, disabled = _ref2.previousDisabled;
      var handleClick = function handleClick2(event) {
        prevButtonOnClick === null || prevButtonOnClick === void 0 ? void 0 : prevButtonOnClick(event);
        if (event.defaultPrevented)
          return;
        onUserNavigation(event);
        event.preventDefault();
        previousSlide();
      };
      return _react["default"].createElement("button", {
        className: prevButtonClassName,
        style: _objectSpread(_objectSpread({}, defaultButtonStyles(disabled)), prevButtonStyle),
        disabled,
        onClick: handleClick,
        "aria-label": "previous",
        "aria-controls": "".concat(carouselId, "-slider-frame"),
        type: "button"
      }, prevButtonText || "Prev");
    };
    exports.PreviousButton = PreviousButton;
    var nextButtonDisabled = function nextButtonDisabled2(_ref3) {
      var cellAlign = _ref3.cellAlign, currentSlide = _ref3.currentSlide, slideCount = _ref3.slideCount, slidesToShow = _ref3.slidesToShow, wrapAround = _ref3.wrapAround;
      if (wrapAround) {
        return false;
      }
      if (currentSlide >= slideCount - 1) {
        return true;
      }
      if (cellAlign === "left" && currentSlide >= slideCount - slidesToShow) {
        return true;
      }
      return false;
    };
    exports.nextButtonDisabled = nextButtonDisabled;
    var NextButton = function NextButton2(_ref4) {
      var nextSlide = _ref4.nextSlide, _ref4$defaultControls = _ref4.defaultControlsConfig, nextButtonClassName = _ref4$defaultControls.nextButtonClassName, _ref4$defaultControls2 = _ref4$defaultControls.nextButtonStyle, nextButtonStyle = _ref4$defaultControls2 === void 0 ? {} : _ref4$defaultControls2, nextButtonText = _ref4$defaultControls.nextButtonText, nextButtonOnClick = _ref4$defaultControls.nextButtonOnClick, carouselId = _ref4.carouselId, disabled = _ref4.nextDisabled, onUserNavigation = _ref4.onUserNavigation;
      var handleClick = function handleClick2(event) {
        nextButtonOnClick === null || nextButtonOnClick === void 0 ? void 0 : nextButtonOnClick(event);
        if (event.defaultPrevented)
          return;
        onUserNavigation(event);
        event.preventDefault();
        nextSlide();
      };
      return _react["default"].createElement("button", {
        className: nextButtonClassName,
        style: _objectSpread(_objectSpread({}, defaultButtonStyles(disabled)), nextButtonStyle),
        disabled,
        onClick: handleClick,
        "aria-label": "next",
        "aria-controls": "".concat(carouselId, "-slider-frame"),
        type: "button"
      }, nextButtonText || "Next");
    };
    exports.NextButton = NextButton;
    var getDotIndexes = function getDotIndexes2(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign) {
      var dotIndexes = [];
      var scrollSlides = slidesToScroll <= 0 ? 1 : slidesToScroll;
      if (wrapAround) {
        for (var i = 0; i < slideCount; i += scrollSlides) {
          dotIndexes.push(i);
        }
        return dotIndexes;
      }
      if (cellAlign === "center") {
        for (var _i = 0; _i < slideCount - 1; _i += scrollSlides) {
          dotIndexes.push(_i);
        }
        if (slideCount > 0) {
          dotIndexes.push(slideCount - 1);
        }
        return dotIndexes;
      }
      if (cellAlign === "left") {
        if (slidesToShow >= slideCount) {
          return [0];
        }
        var lastPossibleIndexWithoutWhitespace = slideCount - slidesToShow;
        for (var _i2 = 0; _i2 < lastPossibleIndexWithoutWhitespace; _i2 += scrollSlides) {
          dotIndexes.push(_i2);
        }
        if (scrollMode === _types.ScrollMode.remainder) {
          dotIndexes.push(lastPossibleIndexWithoutWhitespace);
        } else {
          dotIndexes.push(dotIndexes[dotIndexes.length - 1] + scrollSlides);
        }
        return dotIndexes;
      }
      if (cellAlign === "right") {
        if (slidesToShow >= slideCount) {
          return [slideCount - 1];
        }
        var firstPossibleIndexWithoutWhitespace = slidesToShow - 1;
        if (scrollMode === _types.ScrollMode.remainder) {
          for (var _i3 = firstPossibleIndexWithoutWhitespace; _i3 < slideCount - 1; _i3 += scrollSlides) {
            dotIndexes.push(_i3);
          }
          dotIndexes.push(slideCount - 1);
        } else {
          for (var _i4 = slideCount - 1; _i4 > firstPossibleIndexWithoutWhitespace; _i4 -= scrollSlides) {
            dotIndexes.push(_i4);
          }
          dotIndexes.push(dotIndexes[dotIndexes.length - 1] - scrollSlides);
          dotIndexes.reverse();
        }
        return dotIndexes;
      }
      return dotIndexes;
    };
    exports.getDotIndexes = getDotIndexes;
    var PagingDots = function PagingDots2(_ref5) {
      var pagingDotsIndices = _ref5.pagingDotsIndices, _ref5$defaultControls = _ref5.defaultControlsConfig, pagingDotsContainerClassName = _ref5$defaultControls.pagingDotsContainerClassName, pagingDotsClassName = _ref5$defaultControls.pagingDotsClassName, _ref5$defaultControls2 = _ref5$defaultControls.pagingDotsStyle, pagingDotsStyle = _ref5$defaultControls2 === void 0 ? {} : _ref5$defaultControls2, pagingDotsOnClick = _ref5$defaultControls.pagingDotsOnClick, carouselId = _ref5.carouselId, currentSlide = _ref5.currentSlide, onUserNavigation = _ref5.onUserNavigation, slideCount = _ref5.slideCount, goToSlide = _ref5.goToSlide, tabbed = _ref5.tabbed;
      var listStyles = {
        position: "relative",
        top: -10,
        display: "flex",
        margin: 0,
        padding: 0,
        listStyleType: "none"
      };
      var getButtonStyles = (0, _react.useCallback)(function(active) {
        return {
          cursor: "pointer",
          opacity: active ? 1 : 0.5,
          background: "transparent",
          border: "none",
          fill: "black"
        };
      }, []);
      var currentSlideBounded = (0, _utils.getBoundedIndex)(currentSlide, slideCount);
      if (!tabbed)
        return null;
      return _react["default"].createElement("div", {
        className: pagingDotsContainerClassName,
        style: listStyles,
        "aria-label": "Choose slide to display.",
        role: "tablist"
      }, pagingDotsIndices.map(function(slideIndex, i) {
        var isActive = currentSlideBounded === slideIndex || // sets navigation dots active if the current slide falls in the current index range
        currentSlideBounded < slideIndex && (i === 0 || currentSlideBounded > pagingDotsIndices[i - 1]);
        return _react["default"].createElement("button", {
          key: slideIndex,
          className: ["paging-item", pagingDotsClassName, isActive ? "active" : null].join(" "),
          type: "button",
          style: _objectSpread(_objectSpread({}, getButtonStyles(isActive)), pagingDotsStyle),
          onClick: function onClick(event) {
            pagingDotsOnClick === null || pagingDotsOnClick === void 0 ? void 0 : pagingDotsOnClick(event);
            if (event.defaultPrevented)
              return;
            onUserNavigation(event);
            goToSlide(slideIndex);
          },
          "aria-label": "slide ".concat(slideIndex + 1),
          "aria-selected": isActive,
          "aria-controls": "".concat(carouselId, "-slide-").concat(slideIndex + 1),
          role: "tab"
        }, _react["default"].createElement("svg", {
          className: "paging-dot",
          width: "6",
          height: "6",
          "aria-hidden": "true",
          focusable: "false",
          viewBox: "0 0 6 6"
        }, _react["default"].createElement("circle", {
          cx: "3",
          cy: "3",
          r: "3"
        })));
      }));
    };
    exports.PagingDots = PagingDots;
  }
});

// node_modules/nuka-carousel/es/hooks/use-tween.js
var require_use_tween = __commonJS({
  "node_modules/nuka-carousel/es/hooks/use-tween.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useTween = void 0;
    var _react = require_react();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var useTween = function useTween2(durationMs, easingFunction, navigationNum, shouldInterrupt) {
      var _useState = (0, _react.useState)(1), _useState2 = _slicedToArray(_useState, 2), normalizedTimeRaw = _useState2[0], setNormalizedTime = _useState2[1];
      var startTime = (0, _react.useRef)(Date.now());
      var rAF = (0, _react.useRef)();
      var isFirstRender = (0, _react.useRef)(true);
      var lastNavigationNum = (0, _react.useRef)(null);
      var normalizedTime = lastNavigationNum.current === null || lastNavigationNum.current === navigationNum || shouldInterrupt ? normalizedTimeRaw : 0;
      (0, _react.useEffect)(function() {
        lastNavigationNum.current = navigationNum;
        if (isFirstRender.current) {
          isFirstRender.current = false;
          return;
        }
        if (shouldInterrupt) {
          return;
        }
        startTime.current = Date.now();
        setNormalizedTime(0);
        var tick = function tick2() {
          rAF.current = requestAnimationFrame(function() {
            var currentTime = Date.now();
            var normalizedTime2 = Math.min(1, (currentTime - startTime.current) / durationMs);
            setNormalizedTime(normalizedTime2);
            if (normalizedTime2 < 1) {
              tick2();
            } else {
              rAF.current = void 0;
            }
          });
        };
        tick();
        return function() {
          if (rAF.current !== void 0) {
            cancelAnimationFrame(rAF.current);
            setNormalizedTime(1);
          }
        };
      }, [navigationNum, durationMs, shouldInterrupt]);
      return {
        isAnimating: normalizedTime !== 1,
        value: easingFunction(normalizedTime)
      };
    };
    exports.useTween = useTween;
  }
});

// node_modules/nuka-carousel/es/slider-list.js
var require_slider_list = __commonJS({
  "node_modules/nuka-carousel/es/slider-list.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPercentOffsetForSlide = exports.SliderList = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _defaultControls = require_default_controls();
    var _useTween2 = require_use_tween();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var getPercentOffsetForSlide = function getPercentOffsetForSlide2(currentSlide, slideCount, slidesToShow, cellAlign, wrapAround) {
      var renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;
      var singleSlidePercentOfWhole = 100 / renderedSlideCount;
      var slide0Offset = wrapAround ? -100 / 3 : 0;
      if (cellAlign === "right" && slidesToShow > 1) {
        var excessSlides = slidesToShow - 1;
        slide0Offset += singleSlidePercentOfWhole * excessSlides;
      }
      if (cellAlign === "center" && slidesToShow > 1) {
        var _excessSlides = slidesToShow - 1;
        var excessLeftSlides = _excessSlides / 2;
        slide0Offset += singleSlidePercentOfWhole * excessLeftSlides;
      }
      var currentSlideOffsetFrom0 = 100 / renderedSlideCount * currentSlide;
      return slide0Offset - currentSlideOffsetFrom0;
    };
    exports.getPercentOffsetForSlide = getPercentOffsetForSlide;
    var SliderList = _react["default"].forwardRef(function(_ref, forwardedRef) {
      var animation = _ref.animation, animationDistance = _ref.animationDistance, cellAlign = _ref.cellAlign, children = _ref.children, currentSlide = _ref.currentSlide, disableAnimation = _ref.disableAnimation, disableEdgeSwiping = _ref.disableEdgeSwiping, draggedOffset = _ref.draggedOffset, easing = _ref.easing, edgeEasing = _ref.edgeEasing, isDragging = _ref.isDragging, scrollMode = _ref.scrollMode, slideCount = _ref.slideCount, slidesToScroll = _ref.slidesToScroll, slidesToShow = _ref.slidesToShow, speed = _ref.speed, wrapAround = _ref.wrapAround, slideWidth = _ref.slideWidth, setIsAnimating = _ref.setIsAnimating;
      var renderedSlideCount = wrapAround ? 3 * slideCount : slideCount;
      var listVisibleWidth = slideWidth ? "calc(".concat(slideWidth, " * ").concat(renderedSlideCount, ")") : "".concat(renderedSlideCount * 100 / slidesToShow, "%");
      var percentOffsetForSlideProps = [slideCount, slidesToShow, cellAlign, wrapAround];
      var dotIndexes = (0, _defaultControls.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);
      var clampedDraggedOffset = "".concat(draggedOffset, "px");
      if (isDragging && disableEdgeSwiping && !wrapAround) {
        var clampOffsets = [dotIndexes[0], dotIndexes[dotIndexes.length - 1]].map(function(index) {
          return getPercentOffsetForSlide.apply(void 0, [index].concat(percentOffsetForSlideProps));
        });
        clampedDraggedOffset = "clamp(".concat(clampOffsets[1], "%, ").concat(draggedOffset, "px, ").concat(clampOffsets[0], "%)");
      }
      var slideBasedOffset = getPercentOffsetForSlide.apply(void 0, [currentSlide].concat(percentOffsetForSlideProps));
      var isEdgeEasing = !disableEdgeSwiping && !wrapAround && (currentSlide === dotIndexes[0] && animationDistance < 0 || currentSlide === dotIndexes[dotIndexes.length - 1] && animationDistance > 0);
      var _useTween = (0, _useTween2.useTween)(
        speed,
        !isEdgeEasing ? easing : edgeEasing,
        // animationDistance is assumed to be unique enough that it can be used to
        // detect when a new animation should start. This is used in addition to
        // currentSlide because some animations, such as those with edgeEasing, do
        // not occur due to a change in value of currentSlide
        currentSlide + animationDistance,
        isDragging || disableAnimation || animation === "fade"
      ), transition = _useTween.value, isAnimating = _useTween.isAnimating;
      var positioning;
      if (isDragging || slideBasedOffset !== 0 || isAnimating) {
        if (isDragging) {
          positioning = "translateX(".concat(clampedDraggedOffset, ")");
        } else {
          var transitionOffset = isAnimating ? (1 - transition) * animationDistance : 0;
          positioning = "translateX(calc(".concat(slideBasedOffset, "% - ").concat(transitionOffset, "px))");
        }
      }
      (0, _react.useEffect)(function() {
        setIsAnimating(isAnimating);
      }, [isAnimating, setIsAnimating]);
      return _react["default"].createElement("div", {
        ref: forwardedRef,
        className: "slider-list",
        style: {
          width: listVisibleWidth,
          textAlign: "left",
          userSelect: "auto",
          transform: positioning,
          display: "flex"
        }
      }, children);
    });
    exports.SliderList = SliderList;
    SliderList.displayName = "SliderList";
  }
});

// node_modules/nuka-carousel/es/control-styles.js
var require_control_styles = __commonJS({
  "node_modules/nuka-carousel/es/control-styles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getControlContainerStyles = void 0;
    var _types = require_types();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var commonStyles = {
      position: "absolute",
      display: "flex",
      zIndex: 1,
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    };
    var getControlContainerFlexStyles = function getControlContainerFlexStyles2(pos) {
      var alignItems;
      switch (pos) {
        case _types.Positions.TopLeft:
        case _types.Positions.TopCenter:
        case _types.Positions.TopRight:
          alignItems = "flex-start";
          break;
        case _types.Positions.CenterLeft:
        case _types.Positions.CenterCenter:
        case _types.Positions.CenterRight:
          alignItems = "center";
          break;
        case _types.Positions.BottomLeft:
        case _types.Positions.BottomCenter:
        case _types.Positions.BottomRight:
          alignItems = "flex-end";
          break;
      }
      var justifyContent;
      switch (pos) {
        case _types.Positions.TopLeft:
        case _types.Positions.CenterLeft:
        case _types.Positions.BottomLeft:
          justifyContent = "flex-start";
          break;
        case _types.Positions.TopCenter:
        case _types.Positions.CenterCenter:
        case _types.Positions.BottomCenter:
          justifyContent = "center";
          break;
        case _types.Positions.TopRight:
        case _types.Positions.CenterRight:
        case _types.Positions.BottomRight:
          justifyContent = "flex-end";
          break;
      }
      return {
        alignItems,
        justifyContent
      };
    };
    var getControlContainerStyles = function getControlContainerStyles2(pos) {
      return _objectSpread(_objectSpread({}, getControlContainerFlexStyles(pos)), commonStyles);
    };
    exports.getControlContainerStyles = getControlContainerStyles;
  }
});

// node_modules/nuka-carousel/es/controls.js
var require_controls = __commonJS({
  "node_modules/nuka-carousel/es/controls.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _controlStyles = require_control_styles();
    var _defaultControls = require_default_controls();
    var _types = require_types();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var controlsMap = [{
      funcName: "renderTopLeftControls",
      key: _types.Positions.TopLeft
    }, {
      funcName: "renderTopCenterControls",
      key: _types.Positions.TopCenter
    }, {
      funcName: "renderTopRightControls",
      key: _types.Positions.TopRight
    }, {
      funcName: "renderCenterLeftControls",
      key: _types.Positions.CenterLeft
    }, {
      funcName: "renderCenterCenterControls",
      key: _types.Positions.CenterCenter
    }, {
      funcName: "renderCenterRightControls",
      key: _types.Positions.CenterRight
    }, {
      funcName: "renderBottomLeftControls",
      key: _types.Positions.BottomLeft
    }, {
      funcName: "renderBottomCenterControls",
      key: _types.Positions.BottomCenter
    }, {
      funcName: "renderBottomRightControls",
      key: _types.Positions.BottomRight
    }];
    var renderControls = function renderControls2(props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll) {
      if (props.withoutControls) {
        return null;
      }
      var disableCheckProps = _objectSpread(_objectSpread({}, props), {}, {
        currentSlide,
        slideCount
      });
      var nextDisabled = (0, _defaultControls.nextButtonDisabled)(disableCheckProps);
      var previousDisabled = (0, _defaultControls.prevButtonDisabled)(disableCheckProps);
      var pagingDotsIndices = (0, _defaultControls.getDotIndexes)(slideCount, slidesToScroll, props.scrollMode, props.slidesToShow, props.wrapAround, props.cellAlign);
      return controlsMap.map(function(control) {
        var _props$control$funcNa;
        if (!props[control.funcName] || typeof props[control.funcName] !== "function") {
          return _react["default"].createElement(_react.Fragment, {
            key: control.funcName
          });
        }
        return _react["default"].createElement("div", {
          key: control.funcName,
          style: _objectSpread(_objectSpread({}, (0, _controlStyles.getControlContainerStyles)(control.key)), {}, {
            pointerEvents: "none"
          })
        }, _react["default"].createElement("div", {
          className: ["slider-control-".concat(control.key.toLowerCase()), props.defaultControlsConfig.containerClassName || ""].join(" ").trim(),
          style: {
            pointerEvents: "auto"
          }
        }, (_props$control$funcNa = props[control.funcName]) === null || _props$control$funcNa === void 0 ? void 0 : _props$control$funcNa.call(props, {
          cellAlign: props.cellAlign,
          cellSpacing: props.cellSpacing,
          currentSlide,
          defaultControlsConfig: props.defaultControlsConfig || {},
          carouselId: props.carouselId,
          pagingDotsIndices,
          goToSlide,
          nextDisabled,
          nextSlide,
          onUserNavigation: props.onUserNavigation,
          previousDisabled,
          previousSlide: prevSlide,
          scrollMode: props.scrollMode,
          slideCount,
          slidesToScroll,
          slidesToShow: props.slidesToShow || 1,
          tabbed: props.tabbed,
          vertical: props.vertical,
          wrapAround: props.wrapAround
        })));
      });
    };
    var _default = renderControls;
    exports["default"] = _default;
  }
});

// node_modules/nuka-carousel/es/default-carousel-props.js
var require_default_carousel_props = __commonJS({
  "node_modules/nuka-carousel/es/default-carousel-props.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _types = require_types();
    var _defaultControls = require_default_controls();
    var _announceSlide = require_announce_slide();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var easeOut = function easeOut2(t) {
      return Math.pow(t - 1, 3) + 1;
    };
    var defaultProps = {
      adaptiveHeight: false,
      adaptiveHeightAnimation: true,
      afterSlide: function afterSlide() {
      },
      autoplay: false,
      autoplayInterval: 3e3,
      autoplayReverse: false,
      beforeSlide: function beforeSlide() {
      },
      carouselId: "nuka-carousel",
      cellAlign: "left",
      cellSpacing: 0,
      defaultControlsConfig: {},
      disableAnimation: false,
      disableEdgeSwiping: false,
      dragging: true,
      dragThreshold: 0.5,
      easing: easeOut,
      edgeEasing: easeOut,
      enableKeyboardControls: false,
      frameAriaLabel: "Slider",
      keyCodeConfig: {
        nextSlide: [39, 68, 38, 87],
        previousSlide: [37, 65, 40, 83],
        firstSlide: [81],
        lastSlide: [69],
        pause: [32]
      },
      landmark: false,
      onDragStart: function onDragStart() {
      },
      onDrag: function onDrag() {
      },
      onDragEnd: function onDragEnd() {
      },
      onUserNavigation: function onUserNavigation() {
      },
      pauseOnHover: true,
      renderAnnounceSlideMessage: _announceSlide.defaultRenderAnnounceSlideMessage,
      renderBottomCenterControls: function renderBottomCenterControls(props) {
        return _react["default"].createElement(_defaultControls.PagingDots, props);
      },
      renderCenterLeftControls: function renderCenterLeftControls(props) {
        return _react["default"].createElement(_defaultControls.PreviousButton, props);
      },
      renderCenterRightControls: function renderCenterRightControls(props) {
        return _react["default"].createElement(_defaultControls.NextButton, props);
      },
      scrollMode: _types.ScrollMode.page,
      slidesToScroll: 1,
      slidesToShow: 1,
      speed: 500,
      style: {},
      swiping: true,
      tabbed: true,
      vertical: false,
      withoutControls: false,
      wrapAround: false,
      children: _react["default"].createElement(_react["default"].Fragment, null)
    };
    var _default = defaultProps;
    exports["default"] = _default;
  }
});

// node_modules/nuka-carousel/es/hooks/use-state-with-ref.js
var require_use_state_with_ref = __commonJS({
  "node_modules/nuka-carousel/es/hooks/use-state-with-ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useStateWithRef = void 0;
    var _react = require_react();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var useStateWithRef = function useStateWithRef2(initialState) {
      var _useState = (0, _react.useState)(initialState), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
      var valueRef = (0, _react.useRef)(initialState);
      var setValueAndRef = (0, _react.useCallback)(function(newValue) {
        valueRef.current = newValue;
        setValue(newValue);
      }, []);
      return [value, setValueAndRef, valueRef];
    };
    exports.useStateWithRef = useStateWithRef;
  }
});

// node_modules/nuka-carousel/es/hooks/use-frame-height.js
var require_use_frame_height = __commonJS({
  "node_modules/nuka-carousel/es/hooks/use-frame-height.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.useFrameHeight = void 0;
    var _react = require_react();
    var _useStateWithRef3 = require_use_state_with_ref();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var useFrameHeight = function useFrameHeight2(adaptiveHeight, slidesToShow, slideCount) {
      var _useStateWithRef = (0, _useStateWithRef3.useStateWithRef)([]), _useStateWithRef2 = _slicedToArray(_useStateWithRef, 3), visibleHeights = _useStateWithRef2[0], setVisibleHeights = _useStateWithRef2[1], visibleHeightsRef = _useStateWithRef2[2];
      var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), initializedAdaptiveHeight = _useState2[0], setInitializedAdaptiveHeight = _useState2[1];
      var handleVisibleSlideHeightChange = (0, _react.useCallback)(function(slideIndex, height) {
        var latestVisibleHeights = visibleHeightsRef.current;
        var newVisibleHeights;
        if (height === null) {
          newVisibleHeights = latestVisibleHeights.filter(function(slideHeight) {
            return slideHeight.slideIndex !== slideIndex;
          });
        } else {
          newVisibleHeights = [].concat(_toConsumableArray(latestVisibleHeights), [{
            slideIndex,
            height
          }]);
        }
        setVisibleHeights(newVisibleHeights);
        if (newVisibleHeights.length >= Math.min(slideCount, Math.ceil(slidesToShow))) {
          setInitializedAdaptiveHeight(true);
        }
      }, [slideCount, setVisibleHeights, slidesToShow, visibleHeightsRef]);
      var frameHeight = (0, _react.useMemo)(function() {
        if (adaptiveHeight) {
          if (!initializedAdaptiveHeight) {
            return "auto";
          }
          var maxHeight = Math.max.apply(Math, [0].concat(_toConsumableArray(visibleHeights.map(function(height) {
            return height.height;
          }))));
          return "".concat(maxHeight, "px");
        } else {
          return "auto";
        }
      }, [adaptiveHeight, initializedAdaptiveHeight, visibleHeights]);
      return {
        handleVisibleSlideHeightChange,
        frameHeight,
        initializedAdaptiveHeight
      };
    };
    exports.useFrameHeight = useFrameHeight;
  }
});

// node_modules/nuka-carousel/es/carousel.js
var require_carousel = __commonJS({
  "node_modules/nuka-carousel/es/carousel.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.Carousel = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _slide = _interopRequireDefault(require_slide());
    var _announceSlide = _interopRequireDefault(require_announce_slide());
    var _sliderList = require_slider_list();
    var _types = require_types();
    var _controls = _interopRequireDefault(require_controls());
    var _defaultCarouselProps = _interopRequireDefault(require_default_carousel_props());
    var _utils = require_utils();
    var _useFrameHeight2 = require_use_frame_height();
    var _defaultControls = require_default_controls();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var Carousel = function Carousel2(rawProps) {
      var props = rawProps;
      var adaptiveHeight = props.adaptiveHeight, adaptiveHeightAnimation = props.adaptiveHeightAnimation, afterSlide = props.afterSlide, animation = props.animation, autoplay = props.autoplay, autoplayInterval = props.autoplayInterval, autoplayReverse = props.autoplayReverse, beforeSlide = props.beforeSlide, carouselId = props.carouselId, propsCellAlign = props.cellAlign, cellSpacing = props.cellSpacing, children = props.children, className = props.className, disableAnimation = props.disableAnimation, desktopDraggingEnabled = props.dragging, propsDragThreshold = props.dragThreshold, enableKeyboardControls = props.enableKeyboardControls, frameAriaLabel = props.frameAriaLabel, innerRef = props.innerRef, keyCodeConfig = props.keyCodeConfig, landmark = props.landmark, onDrag = props.onDrag, onDragEnd = props.onDragEnd, onDragStart = props.onDragStart, onUserNavigation = props.onUserNavigation, pauseOnHover = props.pauseOnHover, renderAnnounceSlideMessage = props.renderAnnounceSlideMessage, propsScrollMode = props.scrollMode, slideIndex = props.slideIndex, propsSlidesToScroll = props.slidesToScroll, propsSlidesToShow = props.slidesToShow, slideWidth = props.slideWidth, speed = props.speed, style = props.style, mobileDraggingEnabled = props.swiping, tabbed = props.tabbed, wrapAround = props.wrapAround, zoomScale = props.zoomScale;
      var filteredSlides = _react["default"].Children.toArray(children).filter(Boolean);
      var slideCount = filteredSlides.length;
      var cellAlign = slideWidth || propsSlidesToScroll === "auto" ? "left" : propsCellAlign;
      var scrollMode = propsSlidesToScroll === "auto" ? _types.ScrollMode.remainder : propsScrollMode;
      var _useState = (0, _react.useState)(/* @__PURE__ */ new Map()), _useState2 = _slicedToArray(_useState, 2), slideIOEntries = _useState2[0], setSlideIOEntries = _useState2[1];
      var visibleCount = Array.from(slideIOEntries).filter(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), visible = _ref2[1];
        return visible;
      }).length;
      var _useState3 = (0, _react.useState)(visibleCount), _useState4 = _slicedToArray(_useState3, 2), constantVisibleCount = _useState4[0], setConstantVisibleCount = _useState4[1];
      var slidesToShow = slideWidth ? constantVisibleCount : propsSlidesToShow;
      var slidesToScroll = animation === "fade" ? slidesToShow : propsSlidesToScroll === "auto" ? Math.max(constantVisibleCount, 1) : propsSlidesToScroll;
      var _useState5 = (0, _react.useState)(function() {
        return (0, _utils.getDefaultSlideIndex)(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode);
      }), _useState6 = _slicedToArray(_useState5, 2), currentSlide = _useState6[0], setCurrentSlide = _useState6[1];
      var _useState7 = (0, _react.useState)(false), _useState8 = _slicedToArray(_useState7, 2), pause = _useState8[0], setPause = _useState8[1];
      var _useState9 = (0, _react.useState)(false), _useState10 = _slicedToArray(_useState9, 2), isDragging = _useState10[0], setIsDragging = _useState10[1];
      var _useState11 = (0, _react.useState)(0), _useState12 = _slicedToArray(_useState11, 2), dragDistance = _useState12[0], setDragDistance = _useState12[1];
      var _useState13 = (0, _react.useState)(0), _useState14 = _slicedToArray(_useState13, 2), animationDistance = _useState14[0], setAnimationDistance = _useState14[1];
      var _useState15 = (0, _react.useState)(false), _useState16 = _slicedToArray(_useState15, 2), isAnimating = _useState16[0], setIsAnimating = _useState16[1];
      var updateSlideIOEntry = (0, _react.useCallback)(function(id, isFullyVisible) {
        if (!!slideIOEntries.get(id) === isFullyVisible)
          return;
        setSlideIOEntries(function(prev) {
          var newMap = new Map(prev);
          newMap.set(id, isFullyVisible);
          return newMap;
        });
      }, [slideIOEntries]);
      var prevDragged = (0, _react.useRef)(false);
      (0, _react.useEffect)(function() {
        if (isDragging)
          prevDragged.current = true;
        if (!(isDragging || isAnimating)) {
          if (!prevDragged.current)
            setConstantVisibleCount(visibleCount);
          prevDragged.current = false;
        }
      }, [isAnimating, isDragging, visibleCount]);
      var prevXPosition = (0, _react.useRef)(null);
      var preDragOffset = (0, _react.useRef)(0);
      var sliderListRef = (0, _react.useRef)(null);
      var defaultCarouselRef = (0, _react.useRef)(null);
      var autoplayTimeout = (0, _react.useRef)();
      var autoplayLastTriggeredRef = (0, _react.useRef)(null);
      var isMounted = (0, _react.useRef)(true);
      var setSliderListRef = (0, _react.useCallback)(function(node) {
        if (node) {
          node.querySelectorAll(".slider-list img").forEach(function(el) {
            return el.setAttribute("draggable", "false");
          });
        }
        sliderListRef.current = node;
      }, []);
      (0, _react.useEffect)(function() {
        isMounted.current = true;
        return function() {
          isMounted.current = false;
        };
      }, []);
      var carouselRef = innerRef || defaultCarouselRef;
      var goToSlide = (0, _react.useCallback)(function(targetSlideUnbounded) {
        if (!sliderListRef.current || !carouselRef.current)
          return;
        var targetSlideBounded = (0, _utils.getBoundedIndex)(targetSlideUnbounded, slideCount);
        var slideChanged = targetSlideUnbounded !== currentSlide;
        slideChanged && beforeSlide(currentSlide, targetSlideBounded);
        var currentOffset = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;
        var sliderWidth = sliderListRef.current.offsetWidth;
        var targetOffset = (0, _sliderList.getPercentOffsetForSlide)(targetSlideBounded, slideCount, slidesToShow, cellAlign, wrapAround) / 100 * sliderWidth;
        if (wrapAround) {
          var slideSetWidth = sliderWidth / 3;
          if (targetSlideUnbounded < 0) {
            targetOffset += slideSetWidth;
          }
          if (targetSlideUnbounded >= slideCount) {
            targetOffset -= slideSetWidth;
          }
        }
        setAnimationDistance(targetOffset - currentOffset);
        if (slideChanged) {
          setCurrentSlide(targetSlideBounded);
          var msToEndOfAnimation = !disableAnimation ? speed || 500 : 40;
          setTimeout(function() {
            if (!isMounted.current)
              return;
            afterSlide(targetSlideBounded);
          }, msToEndOfAnimation);
        }
      }, [afterSlide, beforeSlide, carouselRef, cellAlign, currentSlide, disableAnimation, speed, slideCount, slidesToShow, wrapAround]);
      var nextSlide = (0, _react.useCallback)(function() {
        var nextSlideIndex = (0, _utils.getNextMoveIndex)(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign);
        if (currentSlide !== nextSlideIndex) {
          goToSlide(nextSlideIndex);
        }
      }, [cellAlign, currentSlide, goToSlide, slidesToScroll, scrollMode, slideCount, slidesToShow, wrapAround]);
      var prevSlide = (0, _react.useCallback)(function() {
        var prevSlideIndex = (0, _utils.getPrevMoveIndex)(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign);
        if (currentSlide !== prevSlideIndex) {
          goToSlide(prevSlideIndex);
        }
      }, [cellAlign, currentSlide, goToSlide, slidesToScroll, scrollMode, slidesToShow, wrapAround]);
      var prevMovedToSlideIndex = (0, _react.useRef)(slideIndex);
      (0, _react.useEffect)(function() {
        if (slideIndex !== void 0 && slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {
          goToSlide(slideIndex);
          prevMovedToSlideIndex.current = slideIndex;
        }
      }, [slideIndex, autoplayReverse, goToSlide]);
      (0, _react.useEffect)(function() {
        var pauseStarted = null;
        if (pause) {
          pauseStarted = Date.now();
        }
        return function() {
          if (pauseStarted !== null && autoplayLastTriggeredRef.current !== null) {
            autoplayLastTriggeredRef.current += Date.now() - pauseStarted;
          }
        };
      }, [pause]);
      (0, _react.useEffect)(function() {
        if (autoplay && !pause) {
          var adjustedTimeoutMs = autoplayLastTriggeredRef.current !== null ? autoplayInterval - (Date.now() - autoplayLastTriggeredRef.current) : autoplayInterval;
          autoplayTimeout.current = setTimeout(function() {
            autoplayLastTriggeredRef.current = Date.now();
            if (autoplayReverse) {
              prevSlide();
            } else {
              nextSlide();
            }
          }, adjustedTimeoutMs);
        }
        if (autoplay && pause) {
          clearTimeout(autoplayTimeout.current);
        }
        return function() {
          clearTimeout(autoplayTimeout.current);
        };
      }, [pause, autoplay, autoplayInterval, autoplayReverse, prevSlide, nextSlide]);
      var onKeyDown = function onKeyDown2(event) {
        var keyCommand = null;
        Object.keys(keyCodeConfig).forEach(function(command) {
          var _keyCodeConfig$comman;
          if ((_keyCodeConfig$comman = keyCodeConfig[command]) !== null && _keyCodeConfig$comman !== void 0 && _keyCodeConfig$comman.includes(event.keyCode)) {
            keyCommand = command;
          }
        });
        if (keyCommand === null)
          return;
        event.preventDefault();
        event.stopPropagation();
        switch (keyCommand) {
          case "nextSlide":
            onUserNavigation(event);
            nextSlide();
            break;
          case "previousSlide":
            onUserNavigation(event);
            prevSlide();
            break;
          case "firstSlide":
          case "lastSlide": {
            onUserNavigation(event);
            var dotIndices = (0, _defaultControls.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, wrapAround, cellAlign);
            if (keyCommand === "firstSlide") {
              goToSlide(dotIndices[0]);
            } else {
              goToSlide(dotIndices[dotIndices.length - 1]);
            }
            break;
          }
          case "pause":
            setPause(function(p) {
              return !p;
            });
            break;
        }
      };
      var dragPositions = (0, _react.useRef)([]);
      var handleDragEnd = function handleDragEnd2(e) {
        if (!isDragging || !carouselRef.current)
          return;
        setIsDragging(false);
        var distanceFromInertia = 0;
        if (dragPositions.current.length > 1) {
          var startMove = dragPositions.current[0];
          var endMove = dragPositions.current[dragPositions.current.length - 1];
          var timeOffset = endMove.time - startMove.time;
          var goodInertiaFeelConstant = 9;
          var goodFrictionFeelConstant = 0.92;
          var initialVelocity = goodInertiaFeelConstant * Math.abs((endMove.pos - startMove.pos) / timeOffset);
          var velocity = initialVelocity;
          while (Math.abs(velocity) > 1) {
            distanceFromInertia += velocity;
            velocity *= goodFrictionFeelConstant;
          }
        }
        dragPositions.current = [];
        var adjustedDragDistance = Math.abs(dragDistance) + Math.abs(distanceFromInertia);
        onDragEnd(e);
        prevXPosition.current = null;
        setDragDistance(0);
        var oneScrollWidth = carouselRef.current.offsetWidth * Math.min(1, slidesToScroll / slidesToShow);
        var dragThreshold = oneScrollWidth * propsDragThreshold;
        if (adjustedDragDistance < dragThreshold) {
          goToSlide(currentSlide);
          return;
        }
        var canMaintainVisualContinuity = slidesToShow >= 2 * slidesToScroll;
        var timesToMove = canMaintainVisualContinuity ? 1 + Math.floor((adjustedDragDistance - dragThreshold) / oneScrollWidth) : 1;
        var nextSlideIndex = currentSlide;
        for (var index = 0; index < timesToMove; index += 1) {
          if (dragDistance > 0) {
            nextSlideIndex = (0, _utils.getNextMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slideCount, slidesToScroll, slidesToShow, cellAlign);
          } else {
            nextSlideIndex = (0, _utils.getPrevMoveIndex)(scrollMode, wrapAround, nextSlideIndex, slidesToScroll, slidesToShow, cellAlign);
          }
        }
        if (nextSlideIndex !== currentSlide) {
          onUserNavigation(e);
        }
        goToSlide(nextSlideIndex);
      };
      var onTouchStart = (0, _react.useCallback)(function(e) {
        if (!mobileDraggingEnabled || !sliderListRef.current || !carouselRef.current) {
          return;
        }
        setIsDragging(true);
        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;
        onDragStart(e);
      }, [carouselRef, onDragStart, mobileDraggingEnabled]);
      var handlePointerMove = (0, _react.useCallback)(function(xPosition) {
        if (!isDragging)
          return;
        var isFirstMove = prevXPosition.current === null;
        var delta = prevXPosition.current !== null ? xPosition - prevXPosition.current : 0;
        var nextDragDistance = dragDistance + delta;
        var now = Date.now();
        while (dragPositions.current.length > 0) {
          if (now - dragPositions.current[0].time <= 100) {
            break;
          }
          dragPositions.current.shift();
        }
        dragPositions.current.push({
          pos: nextDragDistance,
          time: now
        });
        if (!isFirstMove) {
          setDragDistance(nextDragDistance);
        }
        prevXPosition.current = xPosition;
      }, [isDragging, dragDistance]);
      var onTouchMove = (0, _react.useCallback)(function(e) {
        if (!isDragging || !carouselRef.current)
          return;
        onDragStart(e);
        var moveValue = carouselRef.current.offsetWidth - e.touches[0].pageX;
        handlePointerMove(moveValue);
      }, [isDragging, carouselRef, handlePointerMove, onDragStart]);
      var onMouseDown = (0, _react.useCallback)(function(e) {
        if (!desktopDraggingEnabled || !sliderListRef.current || !carouselRef.current)
          return;
        setIsDragging(true);
        preDragOffset.current = sliderListRef.current.getBoundingClientRect().left - carouselRef.current.getBoundingClientRect().left;
        onDragStart(e);
      }, [carouselRef, desktopDraggingEnabled, onDragStart]);
      var onMouseMove = (0, _react.useCallback)(function(e) {
        if (!isDragging || !carouselRef.current)
          return;
        onDrag(e);
        var offsetX = e.clientX - carouselRef.current.getBoundingClientRect().left;
        var moveValue = carouselRef.current.offsetWidth - offsetX;
        handlePointerMove(moveValue);
      }, [carouselRef, isDragging, handlePointerMove, onDrag]);
      var onMouseUp = function onMouseUp2(e) {
        e.preventDefault();
        handleDragEnd(e);
      };
      var onMouseEnter = (0, _react.useCallback)(function() {
        if (pauseOnHover) {
          setPause(true);
        }
      }, [pauseOnHover]);
      var onMouseLeave = (0, _react.useCallback)(function() {
        if (pauseOnHover) {
          setPause(false);
        }
      }, [pauseOnHover]);
      var _useFrameHeight = (0, _useFrameHeight2.useFrameHeight)(adaptiveHeight, slidesToShow, slideCount), frameHeight = _useFrameHeight.frameHeight, handleVisibleSlideHeightChange = _useFrameHeight.handleVisibleSlideHeightChange, initializedAdaptiveHeight = _useFrameHeight.initializedAdaptiveHeight;
      var renderSlides = function renderSlides2(typeOfSlide) {
        var slides = filteredSlides.map(function(child, index) {
          return _react["default"].createElement(_slide["default"], {
            key: "".concat(typeOfSlide, "-").concat(index),
            id: "".concat(typeOfSlide, "-").concat(index),
            carouselId,
            count: slideCount,
            index,
            isCurrentSlide: currentSlide === index,
            typeOfSlide,
            wrapAround,
            cellSpacing,
            animation,
            speed,
            zoomScale,
            onVisibleSlideHeightChange: handleVisibleSlideHeightChange,
            slideWidth,
            updateIOEntry: updateSlideIOEntry,
            adaptiveHeight,
            initializedAdaptiveHeight,
            carouselRef,
            tabbed
          }, child);
        });
        return slides;
      };
      return _react["default"].createElement("div", {
        className: "slider-container",
        style: {
          position: "relative"
        },
        onMouseEnter,
        onMouseLeave,
        "aria-label": frameAriaLabel,
        role: landmark ? "region" : "group",
        "aria-roledescription": "carousel",
        id: carouselId,
        "data-testid": carouselId
      }, _react["default"].createElement(_announceSlide["default"], {
        ariaLive: autoplay && !pause ? "off" : "polite",
        message: renderAnnounceSlideMessage({
          currentSlide,
          count: slideCount
        })
      }), (0, _controls["default"])(props, slideCount, currentSlide, goToSlide, nextSlide, prevSlide, slidesToScroll), _react["default"].createElement("div", {
        className: ["slider-frame", className || ""].join(" ").trim(),
        style: _objectSpread({
          overflow: "hidden",
          width: "100%",
          position: "relative",
          outline: "none",
          touchAction: "pan-y",
          height: frameHeight,
          transition: adaptiveHeightAnimation ? "height 300ms ease-in-out" : void 0,
          willChange: "height",
          userSelect: "none"
        }, style),
        tabIndex: enableKeyboardControls ? 0 : -1,
        onKeyDown: enableKeyboardControls ? onKeyDown : void 0,
        ref: carouselRef,
        onMouseUp,
        onMouseDown,
        onMouseMove,
        onMouseLeave: onMouseUp,
        onTouchStart,
        onTouchEnd: handleDragEnd,
        onTouchMove,
        id: "".concat(carouselId, "-slider-frame"),
        "data-testid": "".concat(carouselId, "-slider-frame")
      }, _react["default"].createElement(_sliderList.SliderList, {
        animationDistance,
        cellAlign,
        currentSlide,
        disableEdgeSwiping: props.disableEdgeSwiping,
        draggedOffset: preDragOffset.current - dragDistance,
        disableAnimation,
        easing: props.easing,
        edgeEasing: props.edgeEasing,
        isDragging,
        ref: setSliderListRef,
        scrollMode,
        animation,
        slideCount,
        slidesToScroll,
        slidesToShow,
        speed,
        slideWidth,
        wrapAround,
        setIsAnimating
      }, wrapAround ? renderSlides("prev-cloned") : null, renderSlides(), wrapAround ? renderSlides("next-cloned") : null)));
    };
    exports.Carousel = Carousel;
    Carousel.defaultProps = _defaultCarouselProps["default"];
    var _default = Carousel;
    exports["default"] = _default;
  }
});

// node_modules/nuka-carousel/es/index.js
var require_es = __commonJS({
  "node_modules/nuka-carousel/es/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      NextButton: true,
      PreviousButton: true,
      PagingDots: true
    };
    Object.defineProperty(exports, "NextButton", {
      enumerable: true,
      get: function get() {
        return _defaultControls.NextButton;
      }
    });
    Object.defineProperty(exports, "PagingDots", {
      enumerable: true,
      get: function get() {
        return _defaultControls.PagingDots;
      }
    });
    Object.defineProperty(exports, "PreviousButton", {
      enumerable: true,
      get: function get() {
        return _defaultControls.PreviousButton;
      }
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function get() {
        return _carousel.Carousel;
      }
    });
    var _carousel = require_carousel();
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var _defaultControls = require_default_controls();
  }
});
export default require_es();
//# sourceMappingURL=nuka-carousel.js.map
